#!/bin/bash
#
# Copyright 2022 the Bashy-lib Authors (Dan Bornstein et alia).
# Licensed AS IS and WITHOUT WARRANTY under the Apache License, Version 2.0.
# Details: <http://www.apache.org/licenses/LICENSE-2.0>

. "$(dirname "$(readlink -f "$0")")/init.sh" || exit "$?"


#
# Argument parsing
#

function usage {
    lib helpy print-usage "$@" $'
    ${name} [<opt> ...] [--] <command>

    Lists all the subcommands (and sub-subcommands, etc.) of the given
    command.

    ${name} [--help | -h]

    Displays this message.
    '
}

# Want help?
opt-action --call='{ usage; exit }' help/h

# The command to print stuff about.
positional-arg --required --var=cmdName --filter='/^[a-z]/' command

process-args "$@" || call-then-exit "$?" usage --short


#
# Helper functions
#


#
# Main script
#

cmdPath="$(lib --path "${cmdName}")" \
|| exit "$?"

# Derive the directory that the main command is in, including walkin back from
# a `_run`.
if [[ ${cmdPath} =~ ^(.*)/[^/]+/_run$ ]]; then
    cmdDir="${BASH_REMATCH[1]}"
else
    cmdDir="${cmdPath%/*}"
fi

cmds=($(
    cd "${cmdDir}"
    # Non-obvious: `+ugo+x` just means _an_ execute bit is on, which is
    # necessary but not sufficient. We still need to check that the command is
    # actually executable by the user running this script.
    find "${cmdName}" -type f -perm +ugo+x
)) \
|| {
    error-msg "Command not found: ${cmdName}"
    exit 1
}

lines=()
for c in "${cmds[@]}"; do
    if [[ -x "${cmdDir}/${c}" ]]; then
        if [[ ${c} =~ ^(.*)/_run$ ]]; then
            c="${BASH_REMATCH[1]}"
        fi
        lines+=("$(tr <<<"${c}" / ' ')")
    fi
done

printf '%s\n' "${lines[@]}" \
| sort
