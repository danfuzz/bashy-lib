#!/bin/bash
#
# Copyright 2022-2023 the Bashy-lib Authors (Dan Bornstein et alia).
# SPDX-License-Identifier: Apache-2.0

. "$(dirname "$(readlink -f "$0")")/init.sh" || exit "$?"


#
# Argument parsing
#

function usage {
    # Yes, this is a recursive call to this script.
    lib helpy print-usage "$@" $'
    ${name} [<opt> ...] [--] <message>

    Prints a usage message. This does the following to the given <message>:

    * Trim away empty lines at the start and end of the string.
    * Trim away whitespace from the start of lines, based on the indentation of
      the first not-just-whitespace line.
    * Substitute the name of the program for the variable-like string `${name}`.
    * Prepend `Usage:` and a blank line.
    * Print to `stderr`.

    --short
      Prints a short version of the <message>. This only prints double-newline
      delimited sections whose first line starts with `${name}`. In addition, it
      prints just a single newline (not "Usage:") at the start. Note: For this
      to work as intended, always put a double-newline after each command
      summary section.

    ${name} [--help | -h]

    Displays this message.
    '
}

# Want help?
opt-action --call='{ usage; exit }' help/h

# Extract short usage?
opt-toggle --var=short short

# Usage message to print.
positional-arg --required --var=message message

process-args "$@" || call-then-exit "$?" usage --short


#
# Helper functions
#

# Main command implementation.
function print-usage {
    local short="$1"
    local msg="$2"

    info-msg --exec \
    awk <<<"${msg}" \
        -v name="$(this-cmd-name)" \
        -v short="${short}" \
    '
    BEGIN {
        atStart = 1;
        blankCount = 0;
        indentExpr = ""; # Regex to match indentation to strip.
        inShortPart = 0; # Currently in section used for short output?

        print short ? "" : "Usage:\n";
    }

    /^[ \t]*$/ {
        blankCount++;    # Count blank lines, but do not emit them.
        inShortPart = 0; # Also, a blank ends a short-output section.
        next;
    }

    # Determine first-line indentation; convert to regex.
    indentExpr == "" {
        match($0, /^[ \t]*/);
        indentExpr = "^" substr($0, 1, RLENGTH);
    }

    {
        sub(indentExpr, "");

        if (short && ($0 ~ /^\${name}/)) {
            # Short-output section starts with the command name and continues
            # until a blank line.
            inShortPart = 1;
        }

        if (inShortPart || !short) {
            if (blankCount > 0) {
                if (!(atStart || short)) {
                    # Emit some blank lines in the middle of the message.
                    # (Ignore them at the start and end of the message, and if
                    # doing short output.)
                    while (blankCount-- > 0) print "";
                }
                blankCount = 0;
            }

            atStart = 0;
            gsub(/\${name}/, name);

            print;
        }
    }
    '
}


#
# Main script
#

print-usage "${short}" "${message}"
