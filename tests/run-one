#!/bin/bash
#
# Copyright 2022-2023 the Bashy-lib Authors (Dan Bornstein et alia).
# SPDX-License-Identifier: Apache-2.0

. "$(dirname "$(readlink -f "$0")")/_init.sh" || exit "$?"


#
# Argument parsing
#

define-usage $'
    ${name} [<opt> ...] [--] <test-name>

    Runs a single named test. The name of the test is fundamentally the partial
    path from the `tests` directory to the directory of the test, but as a
    commandline convenience:

    * Any prefix on the test which looks like a path to the `tests` directory is
      ignored.
    * If the name consists only of digits and slashes, then it is expanded to
      include the names of the test directories in question, e.g. `01/005` might
      expand into `01-smoke-tests/005-dry-ice`.

    Note that all test directories are expected to be named with a sequential
    numeric prefix followed by a dash.

    --update
      Update the expected output to match the actual output.

    ${help}
'

# Want help?
opt-action --call='{ usage; exit }' help/h

# Update the expected output?
opt-toggle --var=doUpdate update

# The test to run.
positional-arg --required --var=testName --filter='/[0-9][-/a-z0-9]*$/' test-name

process-args "$@" || usage --short


#
# Helper functions
#

# Any errors yet?
anyErrors=0

# Emits an error. This is only used once the test name has been successfully
# found to be an existing test directory.
function emit-error {
    if (( !anyErrors )); then
        error-msg 'Trouble running test:'
        error-msg "  ${testName}"
        error-msg ''
        anyErrors=1
    fi

    error-msg "$@"
}


#
# Main script
#

testsDir="$(this-cmd-dir)"

# Expand (if necessary) and validate the given test name.

if [[ ${testName} =~ ^[/0-9]+$ ]]; then
    # The name appears to be a shorthand that omits the non-numeric portion of
    # the directories. Try to expand it.
    newName='/'
    while [[ ${testName} =~ ^/*([0-9]+)(.*)$ ]]; do
        part="${BASH_REMATCH[1]}"
        testName="${BASH_REMATCH[2]}"
        partExpanded=($(
            lib ls-files --output=lines --cd="${testsDir}${newName}" --dirs \
                --depth=1 --include="^${part}-"
        ))

        case "${#partExpanded[@]}" in
            0)
                error-msg 'Test not found:'
                error-msg "  ${newName#/}${part}"
                exit 1
                ;;
            1)
                : # It's good
                ;;
            *)
                error-msg 'Ambiguous test name:'
                error-msg "  ${newName#/}${part}"
                error-msg --exec printf '    %s\n' "${partExpanded[@]}"
                exit 1
                ;;
        esac

        newName+="${partExpanded[0]}/"
    done

    testName="tests${newName}"
fi

# Drop initial `.../tests/` and/or final `/` on name, if present.
[[ ${testName} =~ ^((.*/)?tests/)?([0-9][-/a-z0-9]*[a-z0-9])/?$ ]] || {
    error-msg 'Cannot parse test name:'
    error-msg "  ${testName}"
    usage --short
    exit 1
}
testName="${BASH_REMATCH[3]}"

testDir="${testsDir}/${testName}"
runScript="${testDir}/run"
infoTxt="${testDir}/info.txt"
expectMd="${testDir}/expect.md"

if [[ !(-d "${testDir}" && -r "${testDir}") ]]; then
    emit-error "Test not found: ${testName}"
    exit 1
fi

# Check the test directory for validity.

if [[ !(-f "${runScript}" && -r "${runScript}") ]]; then
    emit-error 'Run script not found.'
elif [[ ! -x "${runScript}" ]]; then
    emit-error 'Run script not executable. Do this:'
    emit-error "  chmod 755 ${runScript}"
    emit-error ''
fi

if [[ !(-f "${expectMd}" && -r "${expectMd}") ]] && (( !doUpdate )); then
    emit-error 'Expected output not found.'
fi

if [[ !(-f "${infoTxt}" && -r "${infoTxt}") ]]; then
    emit-error 'Info file not found.'
fi

if (( anyErrors )); then
    exit 1
fi

# Run the test!

echo "# ${testName}"

testOutput="$("${runScript}")" \
|| {
    echo "${testOutput}"
    echo "Run script exited with code: $?"
    exit 1
}

if (( doUpdate )); then
    echo >"${expectMd}" "${testOutput}" \
    || exit "$?"
    exit
fi

expectedOutput="$(cat "${expectMd}")" \
|| exit "$?"

if cmp >/dev/null "${expectMd}" <(echo "${testOutput}"); then
    echo "## passed"
else
    echo "## failed"
    echo ''
    diff -u "${expectMd}" <(echo "${testOutput}") \
    | awk '
        # Fix up the diff labels
        !done && /^---/ {
            print "--- expected";
            print "+++ got";
            next;
        }
        !done && /^+++/ {
            done = 1;
            next;
        }
        {
            print;
        }
    '
    exit 1
fi
